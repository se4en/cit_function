1 The underlying idea is to achieve faster parsing by avoiding tabling on sub-computations which are not expensive. The so-called selective magic parser allows the user to apply magic compilation to specific constraints in a grammar which as a result can be processed y- namically in a bottom-up and goal-directed fash- ion. State of the art top-down processing tech- niques are used to deal with the remaining con- straints. Magic is a compilation technique originally de- veloped for goal-directed bottom-up rocessing of logic programs. See, among others, (Ramakrish- nan et al 1992). As shown in (Minnen, 1996) *The presented research was carried out at the Uni- versity of Tfibingen, Germany, as part of the Sonder- forschungsbereich 340. 1A more detailed iscussion of various aspects of the proposed parser can be found in (Minnen, 1998). magic is an interesting technique with respect o natural language processing as it incorporates fil- tering into the logic underlying the grammar and enables elegant control independent filtering im- provements. In this paper we investigate the se- lective application of magic to typed feature gram- mars a type of constraint-logic grammar based on Typed Feature Logic
mar which as a result can be processed y- namically in a bottom-up and goal-directed fash- ion. State of the art top-down processing tech- niques are used to deal with the remaining con- straints. Magic is a compilation technique originally de- veloped for goal-directed bottom-up rocessing of logic programs. See, among others, (Ramakrish- nan et al 1992). As shown in (Minnen, 1996) *The presented research was carried out at the Uni- versity of Tfibingen, Germany, as part of the Sonder- forschungsbereich 340. 1A more detailed iscussion of various aspects of the proposed parser can be found in (Minnen, 1998). magic is an interesting technique with respect o natural language processing as it incorporates fil- tering into the logic underlying the grammar and enables elegant control independent filtering im- provements. In this paper we investigate the se- lective application of magic to typed feature gram- mars a type of constraint-logic grammar based on Typed Feature Logic (Tgv?:; GStz, 1995). Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (HPSG; Pollard and Sag, 1994) as dis- cussed in (GStz and Meurers, 1997a) and (Meur- ers and Minnen
sented research was carried out at the Uni- versity of Tfibingen, Germany, as part of the Sonder- forschungsbereich 340. 1A more detailed iscussion of various aspects of the proposed parser can be found in (Minnen, 1998). magic is an interesting technique with respect o natural language processing as it incorporates fil- tering into the logic underlying the grammar and enables elegant control independent filtering im- provements. In this paper we investigate the se- lective application of magic to typed feature gram- mars a type of constraint-logic grammar based on Typed Feature Logic (Tgv?:; GStz, 1995). Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (HPSG; Pollard and Sag, 1994) as dis- cussed in (GStz and Meurers, 1997a) and (Meur- ers and Minnen, 1997). Typed feature grammar constraints that are inexpensive to resolve are dealt with using the top-down interpreter of the ConTroll grammar development system (GStz and Meurers, 1997b) which uses an advanced search function, an advanced selection function and in- corporates a coroutining mechanism which sup- ports delayed interpretation. The proposed parser is related to the so-calle
 detailed iscussion of various aspects of the proposed parser can be found in (Minnen, 1998). magic is an interesting technique with respect o natural language processing as it incorporates fil- tering into the logic underlying the grammar and enables elegant control independent filtering im- provements. In this paper we investigate the se- lective application of magic to typed feature gram- mars a type of constraint-logic grammar based on Typed Feature Logic (Tgv?:; GStz, 1995). Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (HPSG; Pollard and Sag, 1994) as dis- cussed in (GStz and Meurers, 1997a) and (Meur- ers and Minnen, 1997). Typed feature grammar constraints that are inexpensive to resolve are dealt with using the top-down interpreter of the ConTroll grammar development system (GStz and Meurers, 1997b) which uses an advanced search function, an advanced selection function and in- corporates a coroutining mechanism which sup- ports delayed interpretation. The proposed parser is related to the so-called Lemma Table deduction system (Johnson and DSrre, 1995) which allows the user to specify whether top-down sub-computations are to be table
the proposed parser can be found in (Minnen, 1998). magic is an interesting technique with respect o natural language processing as it incorporates fil- tering into the logic underlying the grammar and enables elegant control independent filtering im- provements. In this paper we investigate the se- lective application of magic to typed feature gram- mars a type of constraint-logic grammar based on Typed Feature Logic (Tgv?:; GStz, 1995). Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (HPSG; Pollard and Sag, 1994) as dis- cussed in (GStz and Meurers, 1997a) and (Meur- ers and Minnen, 1997). Typed feature grammar constraints that are inexpensive to resolve are dealt with using the top-down interpreter of the ConTroll grammar development system (GStz and Meurers, 1997b) which uses an advanced search function, an advanced selection function and in- corporates a coroutining mechanism which sup- ports delayed interpretation. The proposed parser is related to the so-called Lemma Table deduction system (Johnson and DSrre, 1995) which allows the user to specify whether top-down sub-computations are to be tabled. In contrast to Johnson and DSrre's dedu
used as the basis for implementations of Head-driven Phrase Structure Grammar (HPSG; Pollard and Sag, 1994) as dis- cussed in (GStz and Meurers, 1997a) and (Meur- ers and Minnen, 1997). Typed feature grammar constraints that are inexpensive to resolve are dealt with using the top-down interpreter of the ConTroll grammar development system (GStz and Meurers, 1997b) which uses an advanced search function, an advanced selection function and in- corporates a coroutining mechanism which sup- ports delayed interpretation. The proposed parser is related to the so-called Lemma Table deduction system (Johnson and DSrre, 1995) which allows the user to specify whether top-down sub-computations are to be tabled. In contrast to Johnson and DSrre's deduc- tion system, though, the selective magic parsing approach combines top-down and bottom-up con- trol strategies. As such it resembles the parser of the grammar development system Attribute Language Engine (ALE) of (Carpenter and Penn, 1994). Unlike the ALE parser, though, the selec- tive magic parser does not presuppose a phrase structure backbone and is more flexible as to which sub-computations are tabled/filtered. Bottom-up Interpretation of Magic-compiled Typed Fea
 which uses an advanced search function, an advanced selection function and in- corporates a coroutining mechanism which sup- ports delayed interpretation. The proposed parser is related to the so-called Lemma Table deduction system (Johnson and DSrre, 1995) which allows the user to specify whether top-down sub-computations are to be tabled. In contrast to Johnson and DSrre's deduc- tion system, though, the selective magic parsing approach combines top-down and bottom-up con- trol strategies. As such it resembles the parser of the grammar development system Attribute Language Engine (ALE) of (Carpenter and Penn, 1994). Unlike the ALE parser, though, the selec- tive magic parser does not presuppose a phrase structure backbone and is more flexible as to which sub-computations are tabled/filtered. Bottom-up Interpretation of Magic-compiled Typed Feature Grammars We describe typed feature grammars and discuss their use in implementing HPSG grammars. Sub- sequently we present magic compilation of typed 165 Proceedings of EACL '99 feature grammars on the basis of an example and introduce a dynamic bottom-up interpreter that can be used for goM-directed interpretation of magic-compiled typed feature grammars. 2.1
ons are tabled/filtered. Bottom-up Interpretation of Magic-compiled Typed Feature Grammars We describe typed feature grammars and discuss their use in implementing HPSG grammars. Sub- sequently we present magic compilation of typed 165 Proceedings of EACL '99 feature grammars on the basis of an example and introduce a dynamic bottom-up interpreter that can be used for goM-directed interpretation of magic-compiled typed feature grammars. 2.1 Typed Feature Grammars A typed feature grammar consists of a signa- ture and a set of definite clauses over the con- straint language of equations o fTY? (GStz, 1995) terms (HShfeld and Smolka, 1988) which we will refer to as Torz: definite clauses. Equations over TJr? terms can be solved using (graph) unifica- tion provided they are in normal form. (GStz, 1994) describes a normal form for ir~r? terms, where typed feature structures are interpreted as satisfiable normal form T~r?: terms. 2 The signa- ture consists of a type hierarchy and a set of ap- propriateness conditions. Example 1 The signature specified in figure 1 and 2 and the T~r?: definite clauses in figure 3 constitute an example of a typed feature gram- mar. We write T~r? terms in normal form, 
ered. Bottom-up Interpretation of Magic-compiled Typed Feature Grammars We describe typed feature grammars and discuss their use in implementing HPSG grammars. Sub- sequently we present magic compilation of typed 165 Proceedings of EACL '99 feature grammars on the basis of an example and introduce a dynamic bottom-up interpreter that can be used for goM-directed interpretation of magic-compiled typed feature grammars. 2.1 Typed Feature Grammars A typed feature grammar consists of a signa- ture and a set of definite clauses over the con- straint language of equations o fTY? (GStz, 1995) terms (HShfeld and Smolka, 1988) which we will refer to as Torz: definite clauses. Equations over TJr? terms can be solved using (graph) unifica- tion provided they are in normal form. (GStz, 1994) describes a normal form for ir~r? terms, where typed feature structures are interpreted as satisfiable normal form T~r?: terms. 2 The signa- ture consists of a type hierarchy and a set of ap- propriateness conditions. Example 1 The signature specified in figure 1 and 2 and the T~r?: definite clauses in figure 3 constitute an example of a typed feature gram- mar. We write T~r? terms in normal form, i. e., relation Figure 2: Example
resent magic compilation of typed 165 Proceedings of EACL '99 feature grammars on the basis of an example and introduce a dynamic bottom-up interpreter that can be used for goM-directed interpretation of magic-compiled typed feature grammars. 2.1 Typed Feature Grammars A typed feature grammar consists of a signa- ture and a set of definite clauses over the con- straint language of equations o fTY? (GStz, 1995) terms (HShfeld and Smolka, 1988) which we will refer to as Torz: definite clauses. Equations over TJr? terms can be solved using (graph) unifica- tion provided they are in normal form. (GStz, 1994) describes a normal form for ir~r? terms, where typed feature structures are interpreted as satisfiable normal form T~r?: terms. 2 The signa- ture consists of a type hierarchy and a set of ap- propriateness conditions. Example 1 The signature specified in figure 1 and 2 and the T~r?: definite clauses in figure 3 constitute an example of a typed feature gram- mar. We write T~r? terms in normal form, i. e., relation Figure 2: Example of a typed feature grammar signature (part 2) as typed feature structures. In addition, uninfor- mative feature specifications are ignored and typ- ing is left impl
d feature structures. In addition, uninfor- mative feature specifications are ignored and typ- ing is left implicit when immaterial to the example at hand. Equations between typed feature struc- tures are removed by simple substitution or tags indicating structure sharing. Notice that we also use non-numerical tags such as ~ and ~ . In general all boxed items indicate structure sharing. For expository reasons we represent he ARGn features of the append relation as separate argu- ments. Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (Pollard and Sag, 1994). 3 (Meurers and Minnen, 1997) propose a compi- lation of lexical rules into T~r/: definite clauses 2This view of typed feature structures differs from the perspective on typed feature structures as mod- ehng partial information as in (Carpenter, 1992). Typed feature structures as normal form ir~'~E terms are merely syntactic objects. aSee (King, 1994) for a discussion of the appro- priateness of T~-?: for HPSG and a comparison with other feature logic approaches designed for HPSG. (1) constituent( \[PHON ):- LSEM PHON constituent( \[ AGR )' I_Sr~M teAT? 1 constituent( |AGR )' append(\[~,\[~,\
dition, uninfor- mative feature specifications are ignored and typ- ing is left implicit when immaterial to the example at hand. Equations between typed feature struc- tures are removed by simple substitution or tags indicating structure sharing. Notice that we also use non-numerical tags such as ~ and ~ . In general all boxed items indicate structure sharing. For expository reasons we represent he ARGn features of the append relation as separate argu- ments. Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (Pollard and Sag, 1994). 3 (Meurers and Minnen, 1997) propose a compi- lation of lexical rules into T~r/: definite clauses 2This view of typed feature structures differs from the perspective on typed feature structures as mod- ehng partial information as in (Carpenter, 1992). Typed feature structures as normal form ir~'~E terms are merely syntactic objects. aSee (King, 1994) for a discussion of the appro- priateness of T~-?: for HPSG and a comparison with other feature logic approaches designed for HPSG. (1) constituent( \[PHON ):- LSEM PHON constituent( \[ AGR )' I_Sr~M teAT? 1 constituent( |AGR )' append(\[~,\[~,\[~). rCAT ?, \] (2) constituen
ucture sharing. Notice that we also use non-numerical tags such as ~ and ~ . In general all boxed items indicate structure sharing. For expository reasons we represent he ARGn features of the append relation as separate argu- ments. Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (Pollard and Sag, 1994). 3 (Meurers and Minnen, 1997) propose a compi- lation of lexical rules into T~r/: definite clauses 2This view of typed feature structures differs from the perspective on typed feature structures as mod- ehng partial information as in (Carpenter, 1992). Typed feature structures as normal form ir~'~E terms are merely syntactic objects. aSee (King, 1994) for a discussion of the appro- priateness of T~-?: for HPSG and a comparison with other feature logic approaches designed for HPSG. (1) constituent( \[PHON ):- LSEM PHON constituent( \[ AGR )' I_Sr~M teAT? 1 constituent( |AGR )' append(\[~,\[~,\[~). rCAT ?, \] (2) constituent( \[PHON ( ,,,,y ) /xGR ,h.~-,,.~\] )&quot; (3) constituent( |PHON (,leCp,) /AGR ,h,.~-.,.~ I ). LSEM sleep J (4) append((), F'~' ~)&quot; (5) append( 3 | a.ppend(F'x- ~,~, ~Y's\])- Figure 3: Example of a set of T:7:? definite clau
icate structure sharing. For expository reasons we represent he ARGn features of the append relation as separate argu- ments. Typed feature grammars can be used as the basis for implementations of Head-driven Phrase Structure Grammar (Pollard and Sag, 1994). 3 (Meurers and Minnen, 1997) propose a compi- lation of lexical rules into T~r/: definite clauses 2This view of typed feature structures differs from the perspective on typed feature structures as mod- ehng partial information as in (Carpenter, 1992). Typed feature structures as normal form ir~'~E terms are merely syntactic objects. aSee (King, 1994) for a discussion of the appro- priateness of T~-?: for HPSG and a comparison with other feature logic approaches designed for HPSG. (1) constituent( \[PHON ):- LSEM PHON constituent( \[ AGR )' I_Sr~M teAT? 1 constituent( |AGR )' append(\[~,\[~,\[~). rCAT ?, \] (2) constituent( \[PHON ( ,,,,y ) /xGR ,h.~-,,.~\] )&quot; (3) constituent( |PHON (,leCp,) /AGR ,h,.~-.,.~ I ). LSEM sleep J (4) append((), F'~' ~)&quot; (5) append( 3 | a.ppend(F'x- ~,~, ~Y's\])- Figure 3: Example of a set of T:7:? definite clauses which are used to restrict lexical entries. (GStz and Meurers, 1997b) describe a method for com- p
terms are merely syntactic objects. aSee (King, 1994) for a discussion of the appro- priateness of T~-?: for HPSG and a comparison with other feature logic approaches designed for HPSG. (1) constituent( \[PHON ):- LSEM PHON constituent( \[ AGR )' I_Sr~M teAT? 1 constituent( |AGR )' append(\[~,\[~,\[~). rCAT ?, \] (2) constituent( \[PHON ( ,,,,y ) /xGR ,h.~-,,.~\] )&quot; (3) constituent( |PHON (,leCp,) /AGR ,h,.~-.,.~ I ). LSEM sleep J (4) append((), F'~' ~)&quot; (5) append( 3 | a.ppend(F'x- ~,~, ~Y's\])- Figure 3: Example of a set of T:7:? definite clauses which are used to restrict lexical entries. (GStz and Meurers, 1997b) describe a method for com- piling implicational constraints into typed feature grammars and interleaving them with relational constraints. 4 Because of space limitations we have to refrain from an example. The ConTroll gram- mar development system as described in (GStz and Meurers, 1997b) implements the above men- tioned techniques for compiling an HPSG theory into typed feature grammars. 2.2 Magic Compi la t ion Magic is a compilation technique for goal-directed bottom-up processing of logic programs. See, among others, (Ramakrishnan et al 1992). Be- cause magic compilation does not refer 
s which are used to restrict lexical entries. (GStz and Meurers, 1997b) describe a method for com- piling implicational constraints into typed feature grammars and interleaving them with relational constraints. 4 Because of space limitations we have to refrain from an example. The ConTroll gram- mar development system as described in (GStz and Meurers, 1997b) implements the above men- tioned techniques for compiling an HPSG theory into typed feature grammars. 2.2 Magic Compi la t ion Magic is a compilation technique for goal-directed bottom-up processing of logic programs. See, among others, (Ramakrishnan et al 1992). Be- cause magic compilation does not refer to the spe- cific constraint language adopted, its application is not limited to logic programs/grammars: It can be applied to relational extensions of other con- straint languages such as typed feature grammars without further adaptions. Due to space limitations we discuss magic com- pilation by example only. The interested reader is referred to (Nilsson and Maluszynski, 1995) for an introduction. Example 2 We illustrate magic compilation of typed feature grammars with respect to definite 4 (GStz, 1995) proves that this compilation method is sound 
ic programs. See, among others, (Ramakrishnan et al 1992). Be- cause magic compilation does not refer to the spe- cific constraint language adopted, its application is not limited to logic programs/grammars: It can be applied to relational extensions of other con- straint languages such as typed feature grammars without further adaptions. Due to space limitations we discuss magic com- pilation by example only. The interested reader is referred to (Nilsson and Maluszynski, 1995) for an introduction. Example 2 We illustrate magic compilation of typed feature grammars with respect to definite 4 (GStz, 1995) proves that this compilation method is sound in the general case and defines the large class of type constraints for which it is complete. 166 Proceedings of EACL '99 T \ ~ ~ IPHON list \[ ? k ~ . IAGR agr\[ mary / / relation / liY~st elist /g r ~ r - / ~ nelistk~ &quot;st\[ th+d-sing mary If sleep~_LIBJ sem--\] s np v Figure h Example of a typed feature grammar signature (part 1) clause 1 in figure 3. Consider the TJ:? definite clause in figure 4. As a result of magic compi- +\] constituent~ IP&quot;O. ):- \[SZM magic_constituent ~) , PHON constituent( \[AGR )' I.Sr,~ FEAT&quot; \] constituent( \[AGR )' Ls
ocessing often nullify the ben- efit of tabling intermediate r sults. By combin- ing control strategies and allowing the user to specify how to process particular constraints in the grammar the selective magic parser avoids this problem. This solution is based on the ob- servation that there are sub-computations that are relatively cheap and as a result do not need tabling (Johnson and D6rre, 1995; van Noord, 1997). 3.1 Parse Type Specif ication Combining control strategies depends on a way to differentiate between types of constraints. For 168 Proceedings of EACL '99 example, the ALE parser (Carpenter and Penn, 1994) presupposes a phrase structure backbone which can be used to determine whether a con- straint is to be interpreted bottom-up or top- down. In the case of selective magic parsing we use so-called parse types which allow the user to specify how constraints in the grammar are to be interpreted. A literal (goal) is considered a parse lype literal (goal) if it has as its single argument a typed feature structure of a type specified as a parse type. 1? All types in the type hierarchy can be used as parse types. This way parse type specifica- tion supports a flexible filtering component which allows
ponding tosuch a parse type specification is represented schematically in figure 8. Starting from the lexical entries, i. e., word word word Figure 8: Schematic representation ofthe selective magic parsing process the :r~'L definite clauses that specify the word objects in the grammar, phrases are built bottom- up by matching the parse type literals of the def- inite clauses in the grammar against he edges in the table. The non-parse type literals are pro- cessed according to the top-down control strategy 1?The notion of a parse type literal is closely related to that of a memo literal as in (Johnson and DSrre, 1995). l~When a type is specified as a parse type, all its sub-types are considered as parse types as well. This is necessary as otherwise there may e.xist magic variants of definite clauses defining a parse type goal for which no magic facts can be derived which means that the magic literal of these clauses can be interpreted nei- ther top-down nor bottom-up. described in section 3.3. 3.2 Select ive Magic Compi la t ion In order to process parse type goals according to a semi-naive magic control strategy, we apply magic compilation selectively. Only the T~-L definite clauses in a typed feature gra
ge of deep multi- ple indexing is that the linguist does not have to take into account of processing criteria with re- spect to the organization of her/his data as is the case with a standard Prolog search function which indexes on the functor of the first argument. Another important feature of the top-down in- terpreter is its use of a selection function that interprets deterministic goals, i. e., goals which unify with the left-hand side literal of exactly one definite clause in the grammar, prior to non- deterministic goals. This is often referred to as incorporating delerministic closure (DSrre, 1993). Deterministic losure accomplishes a reduction of the number of choice points that need to be set during processing to a minimum. Furthermore, it leads to earlier failure detection. Finally, the used top-down interpreter imple- ments a powerful coroutining mechanism: 12 At run time the processing of a goal is postponed in case it is insufficiently instantiated. Whether or not a goal is sufficiently instantiated is deter- mined on the basis of so-called delay palierns. 13 These are specifications provided by the user that 12Coroutining appears under many different guises, like for example, sus
choice points that need to be set during processing to a minimum. Furthermore, it leads to earlier failure detection. Finally, the used top-down interpreter imple- ments a powerful coroutining mechanism: 12 At run time the processing of a goal is postponed in case it is insufficiently instantiated. Whether or not a goal is sufficiently instantiated is deter- mined on the basis of so-called delay palierns. 13 These are specifications provided by the user that 12Coroutining appears under many different guises, like for example, suspension, residuation, (goal) freez- ing, and blocking. See also (Colmerauer, 1982; Naish, 1986). 13In the literature delay patterns are sometimes also referred to as wait declarations or .block statements. 169 Proceedings ofEACL '99 indicate which restricting information has to be available before a goal is processed. 3.4 Adapted Semi-naive Bottom-up Interpretat ion The definite clauses resulting from selective magic transformation are interpreted using a semi-naive bottom-up interpreter that is adapted in two re- spects. It ensures that non-parse type goals are interpreted using the advanced top-down inter- preter, and it allows non-parse type goals that remain delayed lo
 need to be set during processing to a minimum. Furthermore, it leads to earlier failure detection. Finally, the used top-down interpreter imple- ments a powerful coroutining mechanism: 12 At run time the processing of a goal is postponed in case it is insufficiently instantiated. Whether or not a goal is sufficiently instantiated is deter- mined on the basis of so-called delay palierns. 13 These are specifications provided by the user that 12Coroutining appears under many different guises, like for example, suspension, residuation, (goal) freez- ing, and blocking. See also (Colmerauer, 1982; Naish, 1986). 13In the literature delay patterns are sometimes also referred to as wait declarations or .block statements. 169 Proceedings ofEACL '99 indicate which restricting information has to be available before a goal is processed. 3.4 Adapted Semi-naive Bottom-up Interpretat ion The definite clauses resulting from selective magic transformation are interpreted using a semi-naive bottom-up interpreter that is adapted in two re- spects. It ensures that non-parse type goals are interpreted using the advanced top-down inter- preter, and it allows non-parse type goals that remain delayed locally to be pa
t declarations or .block statements. 169 Proceedings ofEACL '99 indicate which restricting information has to be available before a goal is processed. 3.4 Adapted Semi-naive Bottom-up Interpretat ion The definite clauses resulting from selective magic transformation are interpreted using a semi-naive bottom-up interpreter that is adapted in two re- spects. It ensures that non-parse type goals are interpreted using the advanced top-down inter- preter, and it allows non-parse type goals that remain delayed locally to be passed in and out of sub-computations i a similar fashion as pro- posed by (Johnson and DSrre, 1995). In order to accommodate these changes the adapted semi- naive interpreter enables the use of edges which specify delayed goals. Figure 9 illustrates the adapted match op- eration. The first defining clause of match/3 match(Edge,edge(Goal,Delayed),Table):- definite_clause((Goal :- Body)), select(Lit,Body,Lits), parse_type(Lit), Edge = edge(Lit,DelayedO), edges(Lit,Table,DelayedO,TopDown), advancechtd_interpret(TopDown,Delayed). match(Edge,edge(Goal,Delayed),Table):- definite~lause((Goal :- TopDown)), advanced_td_interpret(TopDown,Delayed). Figure 9: Adapted efinition of mat, oh/3 passes delay
 the grammar, i. e., parse type literals always preced enon-parse type literals. edges(\[Lit\[Lits\],Table,Delayed0,TopDown):- parse_type(Lit), member(edge(Lit,Delayedl),Table), append(Delayed0,Delayedl,Delayed). edges(Lit,Table,Delayed,TopDown). edges(\[\],_,Delayed,TopDown):- append(Delayed,Lit,TopDown). Figure lh Adapted efinition of edges/4 to the remaining non-parse type literals. Subse- quently, the resulting list of literals is passed up again for advanced top-down interpretation. 4 Imp lementat ion The described parser was implemented aspart of the ConTroll grammar development system (GStz and Meurers, 1997b). Figure 10 shows the over- all setup of the ConTroll magic component. The Controll magic component presupposes a parse type specification and a set of delay patterns to determine when non-parse type constraints are to be interpreted. At run-time the goal-directedness of the selective magic parser is further increased by means of using the phonology of the natural language xpression to be parsed as specified by the initial goal to restrict he number of facts that are added to the table during initialization. Only those facts in the grammar corresponding to lex- ical entries that have a value
