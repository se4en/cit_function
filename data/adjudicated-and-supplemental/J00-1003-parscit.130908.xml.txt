a subautomaton is output after all subautomata occurring at its transitions have been output. Our implementation constructs a minimal deterministic automaton by repeating the following for p = 1, . . . , m: 1. Make a copy of A. Determinize and minimize the copy. If it has fewer transitions labeled by nonterminals than the original, then replace Ap by its copy. 2. Replace each transition in Ap of the form (q, A„ q') by (a copy of) automaton A, in a straightforward way. This means that new e-transitions connect q to the start state of A, and the final states of A, to q'. 1 The representation in Mohri and Pereira (1998) is even more compact than ours for grammars that are not self-embedding. However, in this paper we use our representation as an intermediate result in approximating an unrestricted context-free grammar, with the final objective of obtaining a single minimal deterministic automaton. For this purpose, Mohri and Pereira's representation offers little advantage. qB 22 Nederhof Experiments with Regular Approximation 3. Again determinize and minimize Ap and store it for later reference. The automaton obtained for An, after step 3 is the desired result. 4. Methods of Regular Approximation This secti
 5 Application of the RTN method for the grammar in (a). The RTN is given in (b), and (c) presents the approximating finite automaton. We assume A is the start symbol and therefore qA becomes the initial state and q'A becomes the final state in the approximating automaton. For the sake of presentational convenience, the above describes a construction working on the complete grammar. However, our implementation applies the construction separately for each nonterminal in a set N, such that recursive(N) = self, which leads to a separate subautomaton of the compact representation (Section 3). See Nederhof (1998) for a variant of this approximation that constructs finite transducers rather than finite automata. We have further implemented a parameterized version of the RTN approximation. A state of the nondeterministic automaton is now also associated to a list H of length IHI strictly smaller than a number d, which is the parameter to the method. This list represents a history of rule positions that were encountered in the computation leading to the present state. More precisely, we define an item to be an object of the form [A —> a • 0], where A —> ai3 is a rule from the grammar. These are the same 
 given by item [A c • A]; and the history of coming from the rule position given by item [B d • Ae]), in Figure 6 we now have three states of the form gm for each I = [A —> a • 0], as well as three states of the form gAn and q'A The higher we choose d, the more precise the approximation is, since the histories allow the automaton to simulate part of the mechanism of recursion from the original grammar, and the maximum length of the histories corresponds to the number of levels of recursion that can be simulated accurately. 4.2 Refinement of RTN Superset Approximation We rephrase the method of Grimley-Evans (1997) as follows: First, we construct the approximating finite automaton according to the unparameterized RTN method above. Then an additional mechanism is introduced that ensures for each rule A — Xi . X„, separately that the list of visits to the states go, , gni satisfies some reasonable criteria: a visit to g,, with 0 < i < m, should be followed by one to gi+i or go. The latter option amounts to a nested incarnation of the rule. There is a complementary condition for what should precede a visit to q,, with 0 < i < m. Since only pairs of consecutive visits to states from the set {go, ...,grn} ar
ne the partition of mutually recursive nonterminals after transformation. This integration makes use, for example, of the fact that for fixed Ni and fixed f, the set of nonterminals of the form A11, with A E N, is (potentially) mutually right-recursive. A set of such nonterminals can therefore be treated as the corresponding case from Figure 2, assuming the value right. The full formulation of the integrated grammar transformation and construction of the finite automaton is rather long and is therefore not given here. A very similar formulation, for another grammar transformation, is given in Nederhof (1998). Computational Linguistics Volume 26, Number 1 S-C° sr,0 a Ar40 B'0 0 (S d 30 Nederhof Experiments with Regular Approximation 4.4 Superset Approximation through Pushdown Automata The distinction between context-free languages and regular languages can be seen in terms of the distinction between pushdown automata and finite automata. Pushdown automata maintain a stack that is potentially unbounded in height, which allows more complex languages to be recognized than in the case of finite automata. Regular approximation can be achieved by restricting the height of the stack, as we will see in Se
 to the parameterized RTN method from Section 4.1; note that the histories from Section 4.1 in fact function as stacks, the items being the stack symbols. 31 Computational Linguistics Volume 26, Number 1 4.5 Subset Approximation through Pushdown Automata By restricting the height of the stack of a pushdown automaton, one obstructs recognition of a set of strings in the context-free language, and therefore a subset approximation results. This idea was proposed by Krauwer and des Tombe (1981), Langendoen and Langsam (1987), and Pulman (1986), and was rediscovered by Black (1989) and recently by Johnson (1998). Since the latest publication in this area is more explicit in its presentation, we will base our treatment on this, instead of going to the historical roots of the method. One first constructs a modified left-corner recognizer from the grammar, in the form of a pushdown automaton. The stack height is bounded by a low number; Johnson (1998) claims a suitable number would be 5. The motivation for using the left-corner strategy is that the height of the stack maintained by a left-corner parser is already bounded by a constant in the absence of self-embedding. If the artificial bound imposed by 
n be explained as follows. Define the set of all terminals reachable from nonterminal A to be EA = {a a,[3[A —4* aa[3]}. We now approximate the set of strings derivable from A by EA, which is the set of strings consisting of terminals from EA. Our implementation is made slightly more sophisticated by taking EA to be {X I 3B, a, /3[B E N, A B aX0 AX N]}, for each A such that A E N, and recursive(N) = self, for some i. That is, each X E EA is a terminal, or a nonterminal not in the same set Ni as A, but immediately reachable from set N„ through B E N. This method can be generalized, inspired by Stolcke and Segal (1994), who derive N-gram probabilities from stochastic context-free grammars. By ignoring the probabilities, each N = 1, 2, 3, ... gives rise to a superset approximation that can be described as follows: The set of strings derivable from a nonterminal A is approximated by the set of strings al ... an such that • for each substring v = ai±i ai+N (0 < i < n — N) we have A —>* wvy, for some w and y, • for each prefix v =- al ... ai (0 < < n) such that i < N we have A vy, for some y, and • for each suffix v = afro. . an (0 < i < n) such that n — i < N we have A —›* wv, for some w. (Again, the algorithm
 in the number of rules, and note an accompanying sharp increase in the size of the finite automaton. For this method, we see no possibility of accomplishing the complete approximation process, including determinization and minimization, for grammars in our collection that are substantially larger than 50 rules. Since no grammars of interest could be handled by them, the above two methods will be left out of further consideration. 35 Computational Linguistics Volume 26, Number 1 Table 1 Size of the compact representation and number of states and transitions, for the refined RTN approximation (Grimley-Evans 1997). Grammar Size Compact Representation # of States # of Transitions 10 133 11 14 12 427 17 26 13 1,139 17 34 14 4,895 17 36 15 16,297 17 40 16 51,493 19 52 17 208,350 19 52 18 409,348 21 59 19 1,326,256 21 61 Table 2 Size of the compact representation and number of states and transitions, for the superset approximation based on LR automata following Pereira and Wright (1997). Grammar Size Compact Representation # of States # of Transitions 35 15,921 350 2,125 44 24,651 499 4,352 47 151,226 5,112 35,754 50 646,419 ? ? Below, we refer to the unparameterized and parameterized approximations based 
